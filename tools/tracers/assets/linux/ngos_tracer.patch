diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c
index c3e869e..6046cde 100644
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@ -28,7 +28,7 @@ __pure const struct efi_config *__efi_early(void)
 }
 
 #define BOOT_SERVICES(bits)						\
-static void setup_boot_services##bits(struct efi_config *c)		\
+void setup_boot_services##bits(struct efi_config *c)		\
 {									\
 	efi_system_table_##bits##_t *table;				\
 									\
@@ -108,7 +108,7 @@ void efi_char16_printk(efi_system_table_t *table, efi_char16_t *str)
 		       efi_early->text_output, str);
 }
 
-static efi_status_t
+efi_status_t
 __setup_efi_pci32(efi_pci_io_protocol_32 *pci, struct pci_setup_rom **__rom)
 {
 	struct pci_setup_rom *rom = NULL;
@@ -171,7 +171,7 @@ __setup_efi_pci32(efi_pci_io_protocol_32 *pci, struct pci_setup_rom **__rom)
 	return status;
 }
 
-static void
+void
 setup_efi_pci32(struct boot_params *params, void **pci_handle,
 		unsigned long size)
 {
@@ -216,7 +216,7 @@ setup_efi_pci32(struct boot_params *params, void **pci_handle,
 	}
 }
 
-static efi_status_t
+efi_status_t
 __setup_efi_pci64(efi_pci_io_protocol_64 *pci, struct pci_setup_rom **__rom)
 {
 	struct pci_setup_rom *rom;
@@ -278,7 +278,7 @@ __setup_efi_pci64(efi_pci_io_protocol_64 *pci, struct pci_setup_rom **__rom)
 
 }
 
-static void
+void
 setup_efi_pci64(struct boot_params *params, void **pci_handle,
 		unsigned long size)
 {
@@ -332,7 +332,7 @@ setup_efi_pci64(struct boot_params *params, void **pci_handle,
  * just didn't find any PCI devices, but there's no way to tell outside
  * the context of the call.
  */
-static void setup_efi_pci(struct boot_params *params)
+void setup_efi_pci(struct boot_params *params)
 {
 	efi_status_t status;
 	void **pci_handle = NULL;
@@ -370,7 +370,7 @@ static void setup_efi_pci(struct boot_params *params)
 	efi_call_early(free_pool, pci_handle);
 }
 
-static void retrieve_apple_device_properties(struct boot_params *boot_params)
+void retrieve_apple_device_properties(struct boot_params *boot_params)
 {
 	efi_guid_t guid = APPLE_PROPERTIES_PROTOCOL_GUID;
 	struct setup_data *data, *new;
@@ -421,7 +421,7 @@ static void retrieve_apple_device_properties(struct boot_params *boot_params)
 	}
 }
 
-static void setup_quirks(struct boot_params *boot_params)
+void setup_quirks(struct boot_params *boot_params)
 {
 	efi_char16_t const apple[] = { 'A', 'p', 'p', 'l', 'e', 0 };
 	efi_char16_t *fw_vendor = (efi_char16_t *)(unsigned long)
@@ -433,7 +433,7 @@ static void setup_quirks(struct boot_params *boot_params)
 	}
 }
 
-static efi_status_t
+efi_status_t
 setup_uga32(void **uga_handle, unsigned long size, u32 *width, u32 *height)
 {
 	struct efi_uga_draw_protocol *uga = NULL, *first_uga;
@@ -478,7 +478,7 @@ setup_uga32(void **uga_handle, unsigned long size, u32 *width, u32 *height)
 	return status;
 }
 
-static efi_status_t
+efi_status_t
 setup_uga64(void **uga_handle, unsigned long size, u32 *width, u32 *height)
 {
 	struct efi_uga_draw_protocol *uga = NULL, *first_uga;
@@ -526,7 +526,7 @@ setup_uga64(void **uga_handle, unsigned long size, u32 *width, u32 *height)
 /*
  * See if we have Universal Graphics Adapter (UGA) protocol
  */
-static efi_status_t setup_uga(struct screen_info *si, efi_guid_t *uga_proto,
+efi_status_t setup_uga(struct screen_info *si, efi_guid_t *uga_proto,
 			      unsigned long size)
 {
 	efi_status_t status;
@@ -723,7 +723,7 @@ struct boot_params *make_boot_params(struct efi_config *c)
 	return NULL;
 }
 
-static void add_e820ext(struct boot_params *params,
+void add_e820ext(struct boot_params *params,
 			struct setup_data *e820ext, u32 nr_entries)
 {
 	struct setup_data *data;
@@ -745,7 +745,7 @@ static void add_e820ext(struct boot_params *params,
 		params->hdr.setup_data = (unsigned long)e820ext;
 }
 
-static efi_status_t setup_e820(struct boot_params *params,
+efi_status_t setup_e820(struct boot_params *params,
 			       struct setup_data *e820ext, u32 e820ext_size)
 {
 	struct boot_e820_entry *entry = params->e820_table;
@@ -843,7 +843,7 @@ static efi_status_t setup_e820(struct boot_params *params,
 	return EFI_SUCCESS;
 }
 
-static efi_status_t alloc_e820ext(u32 nr_desc, struct setup_data **e820ext,
+efi_status_t alloc_e820ext(u32 nr_desc, struct setup_data **e820ext,
 				  u32 *e820ext_size)
 {
 	efi_status_t status;
@@ -915,7 +915,7 @@ static efi_status_t exit_boot_func(efi_system_table_t *sys_table_arg,
 	return EFI_SUCCESS;
 }
 
-static efi_status_t exit_boot(struct boot_params *boot_params,
+efi_status_t exit_boot(struct boot_params *boot_params,
 			      void *handle, bool is64)
 {
 	unsigned long map_sz, key, desc_size, buff_size;
diff --git a/arch/x86/boot/compressed/kaslr.c b/arch/x86/boot/compressed/kaslr.c
index 91f27ab..de8f8a5 100644
--- a/arch/x86/boot/compressed/kaslr.c
+++ b/arch/x86/boot/compressed/kaslr.c
@@ -49,7 +49,7 @@ extern unsigned long get_cmd_line_ptr(void);
 static const char build_str[] = UTS_RELEASE " (" LINUX_COMPILE_BY "@"
 		LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION;
 
-static unsigned long rotate_xor(unsigned long hash, const void *area,
+unsigned long rotate_xor(unsigned long hash, const void *area,
 				size_t size)
 {
 	size_t i;
@@ -65,7 +65,7 @@ static unsigned long rotate_xor(unsigned long hash, const void *area,
 }
 
 /* Attempt to create a simple but unpredictable starting entropy. */
-static unsigned long get_boot_seed(void)
+unsigned long get_boot_seed(void)
 {
 	unsigned long hash = 0;
 
@@ -105,7 +105,7 @@ enum mem_avoid_index {
 
 static struct mem_vector mem_avoid[MEM_AVOID_MAX];
 
-static bool mem_overlaps(struct mem_vector *one, struct mem_vector *two)
+bool mem_overlaps(struct mem_vector *one, struct mem_vector *two)
 {
 	/* Item one is entirely before item two. */
 	if (one->start + one->size <= two->start)
@@ -125,7 +125,7 @@ char *skip_spaces(const char *str)
 #include "../../../../lib/ctype.c"
 #include "../../../../lib/cmdline.c"
 
-static int
+int
 parse_memmap(char *p, unsigned long long *start, unsigned long long *size)
 {
 	char *oldp;
@@ -165,7 +165,7 @@ parse_memmap(char *p, unsigned long long *start, unsigned long long *size)
 	return -EINVAL;
 }
 
-static void mem_avoid_memmap(char *str)
+void mem_avoid_memmap(char *str)
 {
 	static int i;
 	int rc;
@@ -204,7 +204,7 @@ static void mem_avoid_memmap(char *str)
 		memmap_too_large = true;
 }
 
-static int handle_mem_memmap(void)
+int handle_mem_memmap(void)
 {
 	char *args = (char *)get_cmd_line_ptr();
 	size_t len = strlen((char *)args);
@@ -329,7 +329,7 @@ static int handle_mem_memmap(void)
  * they can be merged, resulting in: [input, output+init_size) which
  * becomes the MEM_AVOID_ZO_RANGE below.
  */
-static void mem_avoid_init(unsigned long input, unsigned long input_size,
+void mem_avoid_init(unsigned long input, unsigned long input_size,
 			   unsigned long output)
 {
 	unsigned long init_size = boot_params->hdr.init_size;
@@ -388,7 +388,7 @@ static void mem_avoid_init(unsigned long input, unsigned long input_size,
  * Does this memory vector overlap a known avoided area? If so, record the
  * overlap region with the lowest address.
  */
-static bool mem_avoid_overlap(struct mem_vector *img,
+bool mem_avoid_overlap(struct mem_vector *img,
 			      struct mem_vector *overlap)
 {
 	int i;
@@ -438,7 +438,7 @@ static unsigned long slot_max;
 
 static unsigned long slot_area_index;
 
-static void store_slot_info(struct mem_vector *region, unsigned long image_size)
+void store_slot_info(struct mem_vector *region, unsigned long image_size)
 {
 	struct slot_area slot_area;
 
@@ -455,7 +455,7 @@ static void store_slot_info(struct mem_vector *region, unsigned long image_size)
 	}
 }
 
-static unsigned long slots_fetch_random(void)
+unsigned long slots_fetch_random(void)
 {
 	unsigned long slot;
 	int i;
@@ -465,6 +465,7 @@ static unsigned long slots_fetch_random(void)
 		return 0;
 
 	slot = kaslr_get_random_long("Physical") % slot_max;
+	slot = 0;
 
 	for (i = 0; i < slot_area_index; i++) {
 		if (slot >= slot_areas[i].num) {
@@ -479,7 +480,7 @@ static unsigned long slots_fetch_random(void)
 	return 0;
 }
 
-static void process_e820_entry(struct boot_e820_entry *entry,
+void process_e820_entry(struct boot_e820_entry *entry,
 			       unsigned long minimum,
 			       unsigned long image_size)
 {
@@ -562,7 +563,7 @@ static void process_e820_entry(struct boot_e820_entry *entry,
 	}
 }
 
-static unsigned long find_random_phys_addr(unsigned long minimum,
+unsigned long find_random_phys_addr(unsigned long minimum,
 					   unsigned long image_size)
 {
 	int i;
@@ -590,7 +591,7 @@ static unsigned long find_random_phys_addr(unsigned long minimum,
 	return slots_fetch_random();
 }
 
-static unsigned long find_random_virt_addr(unsigned long minimum,
+unsigned long find_random_virt_addr(unsigned long minimum,
 					   unsigned long image_size)
 {
 	unsigned long slots, random_addr;
@@ -671,4 +672,5 @@ void choose_random_location(unsigned long input,
 	if (IS_ENABLED(CONFIG_X86_64))
 		random_addr = find_random_virt_addr(LOAD_PHYSICAL_ADDR, output_size);
 	*virt_addr = random_addr;
+	*virt_addr = 0x1000000;
 }
diff --git a/arch/x86/boot/compressed/misc.c b/arch/x86/boot/compressed/misc.c
index c14217c..cb4d150 100644
--- a/arch/x86/boot/compressed/misc.c
+++ b/arch/x86/boot/compressed/misc.c
@@ -169,7 +169,7 @@ void __puthex(unsigned long value)
 }
 
 #if CONFIG_X86_NEED_RELOCS
-static void handle_relocations(void *output, unsigned long output_len,
+void handle_relocations(void *output, unsigned long output_len,
 			       unsigned long virt_addr)
 {
 	int *reloc;
@@ -264,7 +264,7 @@ static inline void handle_relocations(void *output, unsigned long output_len,
 { }
 #endif
 
-static void parse_elf(void *output)
+void parse_elf(void *output)
 {
 #ifdef CONFIG_X86_64
 	Elf64_Ehdr ehdr;
diff --git a/arch/x86/boot/compressed/pagetable.c b/arch/x86/boot/compressed/pagetable.c
index 28029be..a916e6f 100644
--- a/arch/x86/boot/compressed/pagetable.c
+++ b/arch/x86/boot/compressed/pagetable.c
@@ -40,7 +40,7 @@ struct alloc_pgt_data {
  * above. Besides the local callers, this is used as the allocation
  * callback in mapping_info below.
  */
-static void *alloc_pgt_page(void *context)
+void *alloc_pgt_page(void *context)
 {
 	struct alloc_pgt_data *pages = (struct alloc_pgt_data *)context;
 	unsigned char *entry;
diff --git a/arch/x86/include/asm/desc.h b/arch/x86/include/asm/desc.h
index d0a21b1..f903cab 100644
--- a/arch/x86/include/asm/desc.h
+++ b/arch/x86/include/asm/desc.h
@@ -9,7 +9,7 @@
 #include <linux/smp.h>
 #include <linux/percpu.h>
 
-static inline void fill_ldt(struct desc_struct *desc, const struct user_desc *info)
+void fill_ldt(struct desc_struct *desc, const struct user_desc *info)
 {
 	desc->limit0		= info->limit & 0x0ffff;
 
@@ -47,45 +47,45 @@ struct gdt_page {
 DECLARE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page);
 
 /* Provide the original GDT */
-static inline struct desc_struct *get_cpu_gdt_rw(unsigned int cpu)
+struct desc_struct *get_cpu_gdt_rw(unsigned int cpu)
 {
 	return per_cpu(gdt_page, cpu).gdt;
 }
 
 /* Provide the current original GDT */
-static inline struct desc_struct *get_current_gdt_rw(void)
+struct desc_struct *get_current_gdt_rw(void)
 {
 	return this_cpu_ptr(&gdt_page)->gdt;
 }
 
 /* Get the fixmap index for a specific processor */
-static inline unsigned int get_cpu_gdt_ro_index(int cpu)
+unsigned int get_cpu_gdt_ro_index(int cpu)
 {
 	return FIX_GDT_REMAP_BEGIN + cpu;
 }
 
 /* Provide the fixmap address of the remapped GDT */
-static inline struct desc_struct *get_cpu_gdt_ro(int cpu)
+struct desc_struct *get_cpu_gdt_ro(int cpu)
 {
 	unsigned int idx = get_cpu_gdt_ro_index(cpu);
 	return (struct desc_struct *)__fix_to_virt(idx);
 }
 
 /* Provide the current read-only GDT */
-static inline struct desc_struct *get_current_gdt_ro(void)
+struct desc_struct *get_current_gdt_ro(void)
 {
 	return get_cpu_gdt_ro(smp_processor_id());
 }
 
 /* Provide the physical address of the GDT page. */
-static inline phys_addr_t get_cpu_gdt_paddr(unsigned int cpu)
+phys_addr_t get_cpu_gdt_paddr(unsigned int cpu)
 {
 	return per_cpu_ptr_to_phys(get_cpu_gdt_rw(cpu));
 }
 
 #ifdef CONFIG_X86_64
 
-static inline void pack_gate(gate_desc *gate, unsigned type, unsigned long func,
+void pack_gate(gate_desc *gate, unsigned type, unsigned long func,
 			     unsigned dpl, unsigned ist, unsigned seg)
 {
 	gate->offset_low	= PTR_LOW(func);
@@ -101,7 +101,7 @@ static inline void pack_gate(gate_desc *gate, unsigned type, unsigned long func,
 }
 
 #else
-static inline void pack_gate(gate_desc *gate, unsigned char type,
+void pack_gate(gate_desc *gate, unsigned char type,
 			     unsigned long base, unsigned dpl, unsigned flags,
 			     unsigned short seg)
 {
@@ -111,7 +111,7 @@ static inline void pack_gate(gate_desc *gate, unsigned char type,
 
 #endif
 
-static inline int desc_empty(const void *ptr)
+int desc_empty(const void *ptr)
 {
 	const u32 *desc = ptr;
 
@@ -138,28 +138,28 @@ static inline int desc_empty(const void *ptr)
 #define write_gdt_entry(dt, entry, desc, type)	native_write_gdt_entry(dt, entry, desc, type)
 #define write_idt_entry(dt, entry, g)		native_write_idt_entry(dt, entry, g)
 
-static inline void paravirt_alloc_ldt(struct desc_struct *ldt, unsigned entries)
+void paravirt_alloc_ldt(struct desc_struct *ldt, unsigned entries)
 {
 }
 
-static inline void paravirt_free_ldt(struct desc_struct *ldt, unsigned entries)
+void paravirt_free_ldt(struct desc_struct *ldt, unsigned entries)
 {
 }
 #endif	/* CONFIG_PARAVIRT */
 
 #define store_ldt(ldt) asm("sldt %0" : "=m"(ldt))
 
-static inline void native_write_idt_entry(gate_desc *idt, int entry, const gate_desc *gate)
+void native_write_idt_entry(gate_desc *idt, int entry, const gate_desc *gate)
 {
 	memcpy(&idt[entry], gate, sizeof(*gate));
 }
 
-static inline void native_write_ldt_entry(struct desc_struct *ldt, int entry, const void *desc)
+void native_write_ldt_entry(struct desc_struct *ldt, int entry, const void *desc)
 {
 	memcpy(&ldt[entry], desc, 8);
 }
 
-static inline void
+void
 native_write_gdt_entry(struct desc_struct *gdt, int entry, const void *desc, int type)
 {
 	unsigned int size;
@@ -173,7 +173,7 @@ native_write_gdt_entry(struct desc_struct *gdt, int entry, const void *desc, int
 	memcpy(&gdt[entry], desc, size);
 }
 
-static inline void pack_descriptor(struct desc_struct *desc, unsigned long base,
+void pack_descriptor(struct desc_struct *desc, unsigned long base,
 				   unsigned long limit, unsigned char type,
 				   unsigned char flags)
 {
@@ -185,7 +185,7 @@ static inline void pack_descriptor(struct desc_struct *desc, unsigned long base,
 }
 
 
-static inline void set_tssldt_descriptor(void *d, unsigned long addr, unsigned type, unsigned size)
+void set_tssldt_descriptor(void *d, unsigned long addr, unsigned type, unsigned size)
 {
 #ifdef CONFIG_X86_64
 	struct ldttss_desc64 *desc = d;
@@ -205,7 +205,7 @@ static inline void set_tssldt_descriptor(void *d, unsigned long addr, unsigned t
 #endif
 }
 
-static inline void __set_tss_desc(unsigned cpu, unsigned int entry, void *addr)
+void __set_tss_desc(unsigned cpu, unsigned int entry, void *addr)
 {
 	struct desc_struct *d = get_cpu_gdt_rw(cpu);
 	tss_desc tss;
@@ -217,7 +217,7 @@ static inline void __set_tss_desc(unsigned cpu, unsigned int entry, void *addr)
 
 #define set_tss_desc(cpu, addr) __set_tss_desc(cpu, GDT_ENTRY_TSS, addr)
 
-static inline void native_set_ldt(const void *addr, unsigned int entries)
+void native_set_ldt(const void *addr, unsigned int entries)
 {
 	if (likely(entries == 0))
 		asm volatile("lldt %w0"::"q" (0));
@@ -233,22 +233,22 @@ static inline void native_set_ldt(const void *addr, unsigned int entries)
 	}
 }
 
-static inline void native_load_gdt(const struct desc_ptr *dtr)
+void native_load_gdt(const struct desc_ptr *dtr)
 {
 	asm volatile("lgdt %0"::"m" (*dtr));
 }
 
-static inline void native_load_idt(const struct desc_ptr *dtr)
+void native_load_idt(const struct desc_ptr *dtr)
 {
 	asm volatile("lidt %0"::"m" (*dtr));
 }
 
-static inline void native_store_gdt(struct desc_ptr *dtr)
+void native_store_gdt(struct desc_ptr *dtr)
 {
 	asm volatile("sgdt %0":"=m" (*dtr));
 }
 
-static inline void native_store_idt(struct desc_ptr *dtr)
+void native_store_idt(struct desc_ptr *dtr)
 {
 	asm volatile("sidt %0":"=m" (*dtr));
 }
@@ -259,7 +259,7 @@ static inline void native_store_idt(struct desc_ptr *dtr)
  * original writeable version when needed.
  */
 #ifdef CONFIG_X86_64
-static inline void native_load_tr_desc(void)
+void native_load_tr_desc(void)
 {
 	struct desc_ptr gdt;
 	int cpu = raw_smp_processor_id();
@@ -282,13 +282,13 @@ static inline void native_load_tr_desc(void)
 		load_fixmap_gdt(cpu);
 }
 #else
-static inline void native_load_tr_desc(void)
+void native_load_tr_desc(void)
 {
 	asm volatile("ltr %w0"::"q" (GDT_ENTRY_TSS*8));
 }
 #endif
 
-static inline unsigned long native_store_tr(void)
+unsigned long native_store_tr(void)
 {
 	unsigned long tr;
 
@@ -297,7 +297,7 @@ static inline unsigned long native_store_tr(void)
 	return tr;
 }
 
-static inline void native_load_tls(struct thread_struct *t, unsigned int cpu)
+void native_load_tls(struct thread_struct *t, unsigned int cpu)
 {
 	struct desc_struct *gdt = get_cpu_gdt_rw(cpu);
 	unsigned int i;
@@ -308,7 +308,7 @@ static inline void native_load_tls(struct thread_struct *t, unsigned int cpu)
 
 DECLARE_PER_CPU(bool, __tss_limit_invalid);
 
-static inline void force_reload_TR(void)
+void force_reload_TR(void)
 {
 	struct desc_struct *d = get_current_gdt_rw();
 	tss_desc tss;
@@ -331,7 +331,7 @@ static inline void force_reload_TR(void)
  * if and only if you have TIF_IO_BITMAP set or you're switching to a task
  * with TIF_IO_BITMAP set.
  */
-static inline void refresh_tss_limit(void)
+void refresh_tss_limit(void)
 {
 	DEBUG_LOCKS_WARN_ON(preemptible());
 
@@ -348,7 +348,7 @@ static inline void refresh_tss_limit(void)
  * everything works except that IO bitmap will be ignored and all CPL 3 IO
  * instructions will #GP, which is exactly what we want for normal tasks.
  */
-static inline void invalidate_tss_limit(void)
+void invalidate_tss_limit(void)
 {
 	DEBUG_LOCKS_WARN_ON(preemptible());
 
@@ -370,7 +370,7 @@ static inline void invalidate_tss_limit(void)
 	 (info)->useable		== 0)
 
 /* Lots of programs expect an all-zero user_desc to mean "no segment at all". */
-static inline bool LDT_zero(const struct user_desc *info)
+bool LDT_zero(const struct user_desc *info)
 {
 	return (info->base_addr		== 0 &&
 		info->limit		== 0 &&
@@ -382,36 +382,36 @@ static inline bool LDT_zero(const struct user_desc *info)
 		info->useable		== 0);
 }
 
-static inline void clear_LDT(void)
+void clear_LDT(void)
 {
 	set_ldt(NULL, 0);
 }
 
-static inline unsigned long get_desc_base(const struct desc_struct *desc)
+unsigned long get_desc_base(const struct desc_struct *desc)
 {
 	return (unsigned)(desc->base0 | ((desc->base1) << 16) | ((desc->base2) << 24));
 }
 
-static inline void set_desc_base(struct desc_struct *desc, unsigned long base)
+void set_desc_base(struct desc_struct *desc, unsigned long base)
 {
 	desc->base0 = base & 0xffff;
 	desc->base1 = (base >> 16) & 0xff;
 	desc->base2 = (base >> 24) & 0xff;
 }
 
-static inline unsigned long get_desc_limit(const struct desc_struct *desc)
+unsigned long get_desc_limit(const struct desc_struct *desc)
 {
 	return desc->limit0 | (desc->limit << 16);
 }
 
-static inline void set_desc_limit(struct desc_struct *desc, unsigned long limit)
+void set_desc_limit(struct desc_struct *desc, unsigned long limit)
 {
 	desc->limit0 = limit & 0xffff;
 	desc->limit = (limit >> 16) & 0xf;
 }
 
 #ifdef CONFIG_X86_64
-static inline void set_nmi_gate(int gate, void *addr)
+void set_nmi_gate(int gate, void *addr)
 {
 	gate_desc s;
 
@@ -423,12 +423,12 @@ static inline void set_nmi_gate(int gate, void *addr)
 #ifdef CONFIG_TRACING
 extern struct desc_ptr trace_idt_descr;
 extern gate_desc trace_idt_table[];
-static inline void write_trace_idt_entry(int entry, const gate_desc *gate)
+void write_trace_idt_entry(int entry, const gate_desc *gate)
 {
 	write_idt_entry(trace_idt_table, entry, gate);
 }
 
-static inline void _trace_set_gate(int gate, unsigned type, void *addr,
+void _trace_set_gate(int gate, unsigned type, void *addr,
 				   unsigned dpl, unsigned ist, unsigned seg)
 {
 	gate_desc s;
@@ -441,14 +441,14 @@ static inline void _trace_set_gate(int gate, unsigned type, void *addr,
 	write_trace_idt_entry(gate, &s);
 }
 #else
-static inline void write_trace_idt_entry(int entry, const gate_desc *gate)
+void write_trace_idt_entry(int entry, const gate_desc *gate)
 {
 }
 
 #define _trace_set_gate(gate, type, addr, dpl, ist, seg)
 #endif
 
-static inline void _set_gate(int gate, unsigned type, void *addr,
+void _set_gate(int gate, unsigned type, void *addr,
 			     unsigned dpl, unsigned ist, unsigned seg)
 {
 	gate_desc s;
@@ -486,7 +486,7 @@ extern int first_system_vector;
 /* used_vectors is BITMAP for irq is not managed by percpu vector_irq */
 extern unsigned long used_vectors[];
 
-static inline void alloc_system_vector(int vector)
+void alloc_system_vector(int vector)
 {
 	if (!test_bit(vector, used_vectors)) {
 		set_bit(vector, used_vectors);
@@ -506,37 +506,37 @@ static inline void alloc_system_vector(int vector)
 /*
  * This routine sets up an interrupt gate at directory privilege level 3.
  */
-static inline void set_system_intr_gate(unsigned int n, void *addr)
+void set_system_intr_gate(unsigned int n, void *addr)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_INTERRUPT, addr, 0x3, 0, __KERNEL_CS);
 }
 
-static inline void set_system_trap_gate(unsigned int n, void *addr)
+void set_system_trap_gate(unsigned int n, void *addr)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_TRAP, addr, 0x3, 0, __KERNEL_CS);
 }
 
-static inline void set_trap_gate(unsigned int n, void *addr)
+void set_trap_gate(unsigned int n, void *addr)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_TRAP, addr, 0, 0, __KERNEL_CS);
 }
 
-static inline void set_task_gate(unsigned int n, unsigned int gdt_entry)
+void set_task_gate(unsigned int n, unsigned int gdt_entry)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_TASK, (void *)0, 0, 0, (gdt_entry<<3));
 }
 
-static inline void set_intr_gate_ist(int n, void *addr, unsigned ist)
+void set_intr_gate_ist(int n, void *addr, unsigned ist)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_INTERRUPT, addr, 0, ist, __KERNEL_CS);
 }
 
-static inline void set_system_intr_gate_ist(int n, void *addr, unsigned ist)
+void set_system_intr_gate_ist(int n, void *addr, unsigned ist)
 {
 	BUG_ON((unsigned)n > 0xFF);
 	_set_gate(n, GATE_INTERRUPT, addr, 0x3, ist, __KERNEL_CS);
@@ -544,7 +544,7 @@ static inline void set_system_intr_gate_ist(int n, void *addr, unsigned ist)
 
 #ifdef CONFIG_X86_64
 DECLARE_PER_CPU(u32, debug_idt_ctr);
-static inline bool is_debug_idt_enabled(void)
+bool is_debug_idt_enabled(void)
 {
 	if (this_cpu_read(debug_idt_ctr))
 		return true;
@@ -552,24 +552,24 @@ static inline bool is_debug_idt_enabled(void)
 	return false;
 }
 
-static inline void load_debug_idt(void)
+void load_debug_idt(void)
 {
 	load_idt((const struct desc_ptr *)&debug_idt_descr);
 }
 #else
-static inline bool is_debug_idt_enabled(void)
+bool is_debug_idt_enabled(void)
 {
 	return false;
 }
 
-static inline void load_debug_idt(void)
+void load_debug_idt(void)
 {
 }
 #endif
 
 #ifdef CONFIG_TRACING
 extern atomic_t trace_idt_ctr;
-static inline bool is_trace_idt_enabled(void)
+bool is_trace_idt_enabled(void)
 {
 	if (atomic_read(&trace_idt_ctr))
 		return true;
@@ -577,17 +577,17 @@ static inline bool is_trace_idt_enabled(void)
 	return false;
 }
 
-static inline void load_trace_idt(void)
+void load_trace_idt(void)
 {
 	load_idt((const struct desc_ptr *)&trace_idt_descr);
 }
 #else
-static inline bool is_trace_idt_enabled(void)
+bool is_trace_idt_enabled(void)
 {
 	return false;
 }
 
-static inline void load_trace_idt(void)
+void load_trace_idt(void)
 {
 }
 #endif
@@ -599,7 +599,7 @@ static inline void load_trace_idt(void)
  * that doesn't need to disable interrupts, as nothing should be
  * bothering the CPU then.
  */
-static inline void load_current_idt(void)
+void load_current_idt(void)
 {
 	if (is_debug_idt_enabled())
 		load_debug_idt();
diff --git a/arch/x86/kernel/head64.c b/arch/x86/kernel/head64.c
index 9ba7954..46bdf0a 100644
--- a/arch/x86/kernel/head64.c
+++ b/arch/x86/kernel/head64.c
@@ -143,7 +143,7 @@ void __head __startup_64(unsigned long physaddr)
 }
 
 /* Wipe all early page tables except for the kernel symbol map */
-static void __init reset_early_page_tables(void)
+void __init reset_early_page_tables(void)
 {
 	memset(early_top_pgt, 0, sizeof(pgd_t)*(PTRS_PER_PGD-1));
 	next_early_pgt = 0;
@@ -224,13 +224,13 @@ int __init early_make_pgtable(unsigned long address)
 
 /* Don't add a printk in there. printk relies on the PDA which is not initialized 
    yet. */
-static void __init clear_bss(void)
+void __init clear_bss(void)
 {
 	memset(__bss_start, 0,
 	       (unsigned long) __bss_stop - (unsigned long) __bss_start);
 }
 
-static unsigned long get_cmd_line_ptr(void)
+unsigned long get_cmd_line_ptr(void)
 {
 	unsigned long cmd_line_ptr = boot_params.hdr.cmd_line_ptr;
 
@@ -239,7 +239,7 @@ static unsigned long get_cmd_line_ptr(void)
 	return cmd_line_ptr;
 }
 
-static void __init copy_bootdata(char *real_mode_data)
+void __init copy_bootdata(char *real_mode_data)
 {
 	char * command_line;
 	unsigned long cmd_line_ptr;
diff --git a/drivers/firmware/efi/libstub/arm-stub.c b/drivers/firmware/efi/libstub/arm-stub.c
index 8181ac1..27b061e9 100644
--- a/drivers/firmware/efi/libstub/arm-stub.c
+++ b/drivers/firmware/efi/libstub/arm-stub.c
@@ -74,7 +74,7 @@ void efi_char16_printk(efi_system_table_t *sys_table_arg,
 	out->output_string(out, str);
 }
 
-static struct screen_info *setup_graphics(efi_system_table_t *sys_table_arg)
+struct screen_info *setup_graphics(efi_system_table_t *sys_table_arg)
 {
 	efi_guid_t gop_proto = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;
 	efi_status_t status;
diff --git a/drivers/firmware/efi/libstub/efi-stub-helper.c b/drivers/firmware/efi/libstub/efi-stub-helper.c
index b018436..94e6ea2 100644
--- a/drivers/firmware/efi/libstub/efi-stub-helper.c
+++ b/drivers/firmware/efi/libstub/efi-stub-helper.c
@@ -68,7 +68,7 @@ void efi_printk(efi_system_table_t *sys_table_arg, char *str)
 	}
 }
 
-static inline bool mmap_has_headroom(unsigned long buff_size,
+bool mmap_has_headroom(unsigned long buff_size,
 				     unsigned long map_size,
 				     unsigned long desc_size)
 {
@@ -721,7 +721,7 @@ efi_status_t efi_relocate_kernel(efi_system_table_t *sys_table_arg,
  * Get the number of UTF-8 bytes corresponding to an UTF-16 character.
  * This overestimates for surrogates, but that is okay.
  */
-static int efi_utf8_bytes(u16 c)
+int efi_utf8_bytes(u16 c)
 {
 	return 1 + (c >= 0x80) + (c >= 0x800);
 }
@@ -729,7 +729,7 @@ static int efi_utf8_bytes(u16 c)
 /*
  * Convert an UTF-16 string, not necessarily null terminated, to UTF-8.
  */
-static u8 *efi_utf16_to_utf8(u8 *dst, const u16 *src, int n)
+u8 *efi_utf16_to_utf8(u8 *dst, const u16 *src, int n)
 {
 	unsigned int c;
 
diff --git a/drivers/firmware/efi/libstub/gop.c b/drivers/firmware/efi/libstub/gop.c
index 24c461d..958dc8f 100644
--- a/drivers/firmware/efi/libstub/gop.c
+++ b/drivers/firmware/efi/libstub/gop.c
@@ -12,7 +12,7 @@
 #include <asm/efi.h>
 #include <asm/setup.h>
 
-static void find_bits(unsigned long mask, u8 *pos, u8 *size)
+void find_bits(unsigned long mask, u8 *pos, u8 *size)
 {
 	u8 first, len;
 
@@ -35,7 +35,7 @@ static void find_bits(unsigned long mask, u8 *pos, u8 *size)
 	*size = len;
 }
 
-static void
+void
 setup_pixel_info(struct screen_info *si, u32 pixels_per_scan_line,
 		 struct efi_pixel_bitmask pixel_info, int pixel_format)
 {
@@ -85,7 +85,7 @@ setup_pixel_info(struct screen_info *si, u32 pixels_per_scan_line,
 	}
 }
 
-static efi_status_t
+efi_status_t
 __gop_query32(efi_system_table_t *sys_table_arg,
 	      struct efi_graphics_output_protocol_32 *gop32,
 	      struct efi_graphics_output_mode_info **info,
@@ -109,7 +109,7 @@ __gop_query32(efi_system_table_t *sys_table_arg,
 	return status;
 }
 
-static efi_status_t
+efi_status_t
 setup_gop32(efi_system_table_t *sys_table_arg, struct screen_info *si,
             efi_guid_t *proto, unsigned long size, void **gop_handle)
 {
@@ -203,7 +203,7 @@ setup_gop32(efi_system_table_t *sys_table_arg, struct screen_info *si,
 	return status;
 }
 
-static efi_status_t
+efi_status_t
 __gop_query64(efi_system_table_t *sys_table_arg,
 	      struct efi_graphics_output_protocol_64 *gop64,
 	      struct efi_graphics_output_mode_info **info,
@@ -227,7 +227,7 @@ __gop_query64(efi_system_table_t *sys_table_arg,
 	return status;
 }
 
-static efi_status_t
+efi_status_t
 setup_gop64(efi_system_table_t *sys_table_arg, struct screen_info *si,
 	    efi_guid_t *proto, unsigned long size, void **gop_handle)
 {
diff --git a/lib/decompress_inflate.c b/lib/decompress_inflate.c
index 555c06b..aa0d8cc 100644
--- a/lib/decompress_inflate.c
+++ b/lib/decompress_inflate.c
@@ -193,7 +193,7 @@ STATIC int INIT gunzip(unsigned char *buf, long len,
 	return __gunzip(buf, len, fill, flush, out_buf, 0, pos, error);
 }
 #else
-STATIC int INIT __decompress(unsigned char *buf, long len,
+int __decompress(unsigned char *buf, long len,
 			   long (*fill)(void*, unsigned long),
 			   long (*flush)(void*, unsigned long),
 			   unsigned char *out_buf, long out_len,
