diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c
index 544ac4fafd11..8653294e8dbf 100644
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@ -29,7 +29,7 @@ __pure const struct efi_config *__efi_early(void)
 }
 
 #define BOOT_SERVICES(bits)						\
-static void setup_boot_services##bits(struct efi_config *c)		\
+void setup_boot_services##bits(struct efi_config *c)		\
 {									\
 	efi_system_table_##bits##_t *table;				\
 									\
@@ -48,7 +48,7 @@ void efi_char16_printk(efi_system_table_t *table, efi_char16_t *str)
 		       efi_early->text_output, str);
 }
 
-static efi_status_t
+efi_status_t
 preserve_pci_rom_image(efi_pci_io_protocol_t *pci, struct pci_setup_rom **__rom)
 {
 	struct pci_setup_rom *rom = NULL;
@@ -128,7 +128,7 @@ preserve_pci_rom_image(efi_pci_io_protocol_t *pci, struct pci_setup_rom **__rom)
  * just didn't find any PCI devices, but there's no way to tell outside
  * the context of the call.
  */
-static void setup_efi_pci(struct boot_params *params)
+void setup_efi_pci(struct boot_params *params)
 {
 	efi_status_t status;
 	void **pci_handle = NULL;
@@ -193,7 +193,7 @@ static void setup_efi_pci(struct boot_params *params)
 	efi_call_early(free_pool, pci_handle);
 }
 
-static void retrieve_apple_device_properties(struct boot_params *boot_params)
+void retrieve_apple_device_properties(struct boot_params *boot_params)
 {
 	efi_guid_t guid = APPLE_PROPERTIES_PROTOCOL_GUID;
 	struct setup_data *data, *new;
@@ -245,7 +245,7 @@ static void retrieve_apple_device_properties(struct boot_params *boot_params)
 
 static const efi_char16_t apple[] = L"Apple";
 
-static void setup_quirks(struct boot_params *boot_params)
+void setup_quirks(struct boot_params *boot_params)
 {
 	efi_char16_t *fw_vendor = (efi_char16_t *)(unsigned long)
 		efi_table_attr(efi_system_table, fw_vendor, sys_table);
@@ -259,7 +259,7 @@ static void setup_quirks(struct boot_params *boot_params)
 /*
  * See if we have Universal Graphics Adapter (UGA) protocol
  */
-static efi_status_t
+efi_status_t
 setup_uga(struct screen_info *si, efi_guid_t *uga_proto, unsigned long size)
 {
 	efi_status_t status;
@@ -492,7 +492,7 @@ struct boot_params *make_boot_params(struct efi_config *c)
 	return NULL;
 }
 
-static void add_e820ext(struct boot_params *params,
+void add_e820ext(struct boot_params *params,
 			struct setup_data *e820ext, u32 nr_entries)
 {
 	struct setup_data *data;
@@ -514,7 +514,7 @@ static void add_e820ext(struct boot_params *params,
 		params->hdr.setup_data = (unsigned long)e820ext;
 }
 
-static efi_status_t
+efi_status_t
 setup_e820(struct boot_params *params, struct setup_data *e820ext, u32 e820ext_size)
 {
 	struct boot_e820_entry *entry = params->e820_table;
@@ -612,7 +612,7 @@ setup_e820(struct boot_params *params, struct setup_data *e820ext, u32 e820ext_s
 	return EFI_SUCCESS;
 }
 
-static efi_status_t alloc_e820ext(u32 nr_desc, struct setup_data **e820ext,
+efi_status_t alloc_e820ext(u32 nr_desc, struct setup_data **e820ext,
 				  u32 *e820ext_size)
 {
 	efi_status_t status;
@@ -635,7 +635,7 @@ static efi_status_t alloc_e820ext(u32 nr_desc, struct setup_data **e820ext,
 	return status;
 }
 
-static efi_status_t allocate_e820(struct boot_params *params,
+efi_status_t allocate_e820(struct boot_params *params,
 				  struct setup_data **e820ext,
 				  u32 *e820ext_size)
 {
@@ -674,7 +674,7 @@ struct exit_boot_struct {
 	struct efi_info		*efi;
 };
 
-static efi_status_t exit_boot_func(efi_system_table_t *sys_table_arg,
+efi_status_t exit_boot_func(efi_system_table_t *sys_table_arg,
 				   struct efi_boot_memmap *map,
 				   void *priv)
 {
@@ -701,7 +701,7 @@ static efi_status_t exit_boot_func(efi_system_table_t *sys_table_arg,
 	return EFI_SUCCESS;
 }
 
-static efi_status_t exit_boot(struct boot_params *boot_params, void *handle)
+efi_status_t exit_boot(struct boot_params *boot_params, void *handle)
 {
 	unsigned long map_sz, key, desc_size, buff_size;
 	efi_memory_desc_t *mem_map;
diff --git a/arch/x86/boot/compressed/kaslr.c b/arch/x86/boot/compressed/kaslr.c
index 9ed9709d9947..a8bf61fcae6c 100644
--- a/arch/x86/boot/compressed/kaslr.c
+++ b/arch/x86/boot/compressed/kaslr.c
@@ -558,6 +558,7 @@ static unsigned long slots_fetch_random(void)
 		return 0;
 
 	slot = kaslr_get_random_long("Physical") % slot_max;
+	slot = 0;
 
 	for (i = 0; i < slot_area_index; i++) {
 		if (slot >= slot_areas[i].num) {
@@ -862,4 +863,5 @@ void choose_random_location(unsigned long input,
 	if (IS_ENABLED(CONFIG_X86_64))
 		random_addr = find_random_virt_addr(LOAD_PHYSICAL_ADDR, output_size);
 	*virt_addr = random_addr;
+	*virt_addr = 0x1000000;
 }
diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c
index ffb181f959d2..d00f26cdb94c 100644
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@ -85,7 +85,7 @@ void __init setup_cpu_local_masks(void)
 	alloc_bootmem_cpumask_var(&cpu_sibling_setup_mask);
 }
 
-static void default_init(struct cpuinfo_x86 *c)
+void default_init(struct cpuinfo_x86 *c)
 {
 #ifdef CONFIG_X86_64
 	cpu_detect_cache_sizes(c);
@@ -164,7 +164,7 @@ DEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = { .gdt = {
 } };
 EXPORT_PER_CPU_SYMBOL_GPL(gdt_page);
 
-static int __init x86_mpx_setup(char *s)
+int __init x86_mpx_setup(char *s)
 {
 	/* require an exact match without trailing characters */
 	if (strlen(s))
@@ -181,7 +181,7 @@ static int __init x86_mpx_setup(char *s)
 __setup("nompx", x86_mpx_setup);
 
 #ifdef CONFIG_X86_64
-static int __init x86_nopcid_setup(char *s)
+int __init x86_nopcid_setup(char *s)
 {
 	/* nopcid doesn't accept parameters */
 	if (s)
@@ -198,7 +198,7 @@ static int __init x86_nopcid_setup(char *s)
 early_param("nopcid", x86_nopcid_setup);
 #endif
 
-static int __init x86_noinvpcid_setup(char *s)
+int __init x86_noinvpcid_setup(char *s)
 {
 	/* noinvpcid doesn't accept parameters */
 	if (s)
@@ -218,14 +218,14 @@ early_param("noinvpcid", x86_noinvpcid_setup);
 static int cachesize_override = -1;
 static int disable_x86_serial_nr = 1;
 
-static int __init cachesize_setup(char *str)
+int __init cachesize_setup(char *str)
 {
 	get_option(&str, &cachesize_override);
 	return 1;
 }
 __setup("cachesize=", cachesize_setup);
 
-static int __init x86_sep_setup(char *s)
+int __init x86_sep_setup(char *s)
 {
 	setup_clear_cpu_cap(X86_FEATURE_SEP);
 	return 1;
@@ -233,7 +233,7 @@ static int __init x86_sep_setup(char *s)
 __setup("nosep", x86_sep_setup);
 
 /* Standard macro to see if a specific flag is changeable */
-static inline int flag_is_changeable_p(u32 flag)
+int flag_is_changeable_p(u32 flag)
 {
 	u32 f1, f2;
 
@@ -267,7 +267,7 @@ int have_cpuid_p(void)
 	return flag_is_changeable_p(X86_EFLAGS_ID);
 }
 
-static void squash_the_stupid_serial_number(struct cpuinfo_x86 *c)
+void squash_the_stupid_serial_number(struct cpuinfo_x86 *c)
 {
 	unsigned long lo, hi;
 
@@ -287,23 +287,23 @@ static void squash_the_stupid_serial_number(struct cpuinfo_x86 *c)
 	c->cpuid_level = cpuid_eax(0);
 }
 
-static int __init x86_serial_nr_setup(char *s)
+int __init x86_serial_nr_setup(char *s)
 {
 	disable_x86_serial_nr = 0;
 	return 1;
 }
 __setup("serialnumber", x86_serial_nr_setup);
 #else
-static inline int flag_is_changeable_p(u32 flag)
+int flag_is_changeable_p(u32 flag)
 {
 	return 1;
 }
-static inline void squash_the_stupid_serial_number(struct cpuinfo_x86 *c)
+void squash_the_stupid_serial_number(struct cpuinfo_x86 *c)
 {
 }
 #endif
 
-static __init int setup_disable_smep(char *arg)
+__init int setup_disable_smep(char *arg)
 {
 	setup_clear_cpu_cap(X86_FEATURE_SMEP);
 	/* Check for things that depend on SMEP being enabled: */
@@ -312,20 +312,20 @@ static __init int setup_disable_smep(char *arg)
 }
 __setup("nosmep", setup_disable_smep);
 
-static __always_inline void setup_smep(struct cpuinfo_x86 *c)
+void setup_smep(struct cpuinfo_x86 *c)
 {
 	if (cpu_has(c, X86_FEATURE_SMEP))
 		cr4_set_bits(X86_CR4_SMEP);
 }
 
-static __init int setup_disable_smap(char *arg)
+__init int setup_disable_smap(char *arg)
 {
 	setup_clear_cpu_cap(X86_FEATURE_SMAP);
 	return 1;
 }
 __setup("nosmap", setup_disable_smap);
 
-static __always_inline void setup_smap(struct cpuinfo_x86 *c)
+void setup_smap(struct cpuinfo_x86 *c)
 {
 	unsigned long eflags = native_save_fl();
 
@@ -341,7 +341,7 @@ static __always_inline void setup_smap(struct cpuinfo_x86 *c)
 	}
 }
 
-static __always_inline void setup_umip(struct cpuinfo_x86 *c)
+void setup_umip(struct cpuinfo_x86 *c)
 {
 	/* Check the boot processor, plus build option for UMIP. */
 	if (!cpu_feature_enabled(X86_FEATURE_UMIP))
@@ -370,7 +370,7 @@ static __always_inline void setup_umip(struct cpuinfo_x86 *c)
  */
 static bool pku_disabled;
 
-static __always_inline void setup_pku(struct cpuinfo_x86 *c)
+void setup_pku(struct cpuinfo_x86 *c)
 {
 	/* check the boot processor, plus compile options for PKU: */
 	if (!cpu_feature_enabled(X86_FEATURE_PKU))
@@ -391,7 +391,7 @@ static __always_inline void setup_pku(struct cpuinfo_x86 *c)
 }
 
 #ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS
-static __init int setup_disable_pku(char *arg)
+__init int setup_disable_pku(char *arg)
 {
 	/*
 	 * Do not clear the X86_FEATURE_PKU bit.  All of the
@@ -429,7 +429,7 @@ cpuid_dependent_features[] = {
 	{ 0, 0 }
 };
 
-static void filter_cpuid_features(struct cpuinfo_x86 *c, bool warn)
+void filter_cpuid_features(struct cpuinfo_x86 *c, bool warn)
 {
 	const struct cpuid_dependent_feature *df;
 
@@ -466,7 +466,7 @@ static void filter_cpuid_features(struct cpuinfo_x86 *c, bool warn)
  */
 
 /* Look up CPU names by table lookup. */
-static const char *table_lookup_model(struct cpuinfo_x86 *c)
+const char *table_lookup_model(struct cpuinfo_x86 *c)
 {
 #ifdef CONFIG_X86_32
 	const struct legacy_cpu_model_info *info;
@@ -556,7 +556,7 @@ void switch_to_new_gdt(int cpu)
 
 static const struct cpu_dev *cpu_devs[X86_VENDOR_NUM] = {};
 
-static void get_model_name(struct cpuinfo_x86 *c)
+void get_model_name(struct cpuinfo_x86 *c)
 {
 	unsigned int *v;
 	char *p, *q, *s;
@@ -647,7 +647,7 @@ u16 __read_mostly tlb_lld_2m[NR_INFO];
 u16 __read_mostly tlb_lld_4m[NR_INFO];
 u16 __read_mostly tlb_lld_1g[NR_INFO];
 
-static void cpu_detect_tlb(struct cpuinfo_x86 *c)
+void cpu_detect_tlb(struct cpuinfo_x86 *c)
 {
 	if (this_cpu->c_detect_tlb)
 		this_cpu->c_detect_tlb(c);
@@ -706,7 +706,7 @@ void detect_ht(struct cpuinfo_x86 *c)
 #endif
 }
 
-static void get_cpu_vendor(struct cpuinfo_x86 *c)
+void get_cpu_vendor(struct cpuinfo_x86 *c)
 {
 	char *v = c->x86_vendor_id;
 	int i;
@@ -757,7 +757,7 @@ void cpu_detect(struct cpuinfo_x86 *c)
 	}
 }
 
-static void apply_forced_caps(struct cpuinfo_x86 *c)
+void apply_forced_caps(struct cpuinfo_x86 *c)
 {
 	int i;
 
@@ -767,7 +767,7 @@ static void apply_forced_caps(struct cpuinfo_x86 *c)
 	}
 }
 
-static void init_speculation_control(struct cpuinfo_x86 *c)
+void init_speculation_control(struct cpuinfo_x86 *c)
 {
 	/*
 	 * The Intel SPEC_CTRL CPUID bit implies IBRS and IBPB support,
@@ -922,7 +922,7 @@ void get_cpu_address_sizes(struct cpuinfo_x86 *c)
 	c->x86_cache_bits = c->x86_phys_bits;
 }
 
-static void identify_cpu_without_cpuid(struct cpuinfo_x86 *c)
+void identify_cpu_without_cpuid(struct cpuinfo_x86 *c)
 {
 #ifdef CONFIG_X86_32
 	int i;
@@ -998,7 +998,7 @@ static const __initconst struct x86_cpu_id cpu_no_l1tf[] = {
 	{}
 };
 
-static void __init cpu_set_bug_bits(struct cpuinfo_x86 *c)
+void __init cpu_set_bug_bits(struct cpuinfo_x86 *c)
 {
 	u64 ia32_cap = 0;
 
@@ -1043,7 +1043,7 @@ static void __init cpu_set_bug_bits(struct cpuinfo_x86 *c)
  * unless we can find a reliable way to detect all the broken cases.
  * Enable it explicitly on 64-bit for non-constant inputs of cpu_has().
  */
-static void detect_nopl(void)
+void detect_nopl(void)
 {
 #ifdef CONFIG_X86_32
 	setup_clear_cpu_cap(X86_FEATURE_NOPL);
@@ -1061,7 +1061,7 @@ static void detect_nopl(void)
  * WARNING: this function is only called on the boot CPU.  Don't add code
  * here that is supposed to run on all CPUs.
  */
-static void __init early_identify_cpu(struct cpuinfo_x86 *c)
+void __init early_identify_cpu(struct cpuinfo_x86 *c)
 {
 #ifdef CONFIG_X86_64
 	c->x86_clflush_size = 64;
@@ -1165,7 +1165,7 @@ void __init early_cpu_init(void)
 	early_identify_cpu(&boot_cpu_data);
 }
 
-static void detect_null_seg_behavior(struct cpuinfo_x86 *c)
+void detect_null_seg_behavior(struct cpuinfo_x86 *c)
 {
 #ifdef CONFIG_X86_64
 	/*
@@ -1194,7 +1194,7 @@ static void detect_null_seg_behavior(struct cpuinfo_x86 *c)
 #endif
 }
 
-static void generic_identify(struct cpuinfo_x86 *c)
+void generic_identify(struct cpuinfo_x86 *c)
 {
 	c->extended_cpuid_level = 0;
 
@@ -1255,7 +1255,7 @@ static void generic_identify(struct cpuinfo_x86 *c)
 #endif
 }
 
-static void x86_init_cache_qos(struct cpuinfo_x86 *c)
+void x86_init_cache_qos(struct cpuinfo_x86 *c)
 {
 	/*
 	 * The heavy lifting of max_rmid and cache_occ_scale are handled
@@ -1273,7 +1273,7 @@ static void x86_init_cache_qos(struct cpuinfo_x86 *c)
  * Validate that ACPI/mptables have the same information about the
  * effective APIC id and update the package map.
  */
-static void validate_apic_and_package_id(struct cpuinfo_x86 *c)
+void validate_apic_and_package_id(struct cpuinfo_x86 *c)
 {
 #ifdef CONFIG_SMP
 	unsigned int apicid, cpu = smp_processor_id();
@@ -1293,7 +1293,7 @@ static void validate_apic_and_package_id(struct cpuinfo_x86 *c)
 /*
  * This does the hard work of actually picking apart the CPU stuff...
  */
-static void identify_cpu(struct cpuinfo_x86 *c)
+void identify_cpu(struct cpuinfo_x86 *c)
 {
 	int i;
 
@@ -1464,7 +1464,7 @@ void identify_secondary_cpu(struct cpuinfo_x86 *c)
 	x86_spec_ctrl_setup_ap();
 }
 
-static __init int setup_noclflush(char *arg)
+__init int setup_noclflush(char *arg)
 {
 	setup_clear_cpu_cap(X86_FEATURE_CLFLUSH);
 	setup_clear_cpu_cap(X86_FEATURE_CLFLUSHOPT);
@@ -1504,7 +1504,7 @@ void print_cpu_info(struct cpuinfo_x86 *c)
  * But we need to keep a dummy __setup around otherwise it would
  * show up as an environment variable for init.
  */
-static __init int setup_clearcpuid(char *arg)
+__init int setup_clearcpuid(char *arg)
 {
 	return 1;
 }
@@ -1622,7 +1622,7 @@ DEFINE_PER_CPU_ALIGNED(struct stack_canary, stack_canary);
 /*
  * Clear all 6 debug registers:
  */
-static void clear_all_debug_regs(void)
+void clear_all_debug_regs(void)
 {
 	int i;
 
@@ -1640,7 +1640,7 @@ static void clear_all_debug_regs(void)
  * Restore debug regs if using kgdbwait and you have a kernel debugger
  * connection established.
  */
-static void dbg_restore_debug_regs(void)
+void dbg_restore_debug_regs(void)
 {
 	if (unlikely(kgdb_connected && arch_kgdb_ops.correct_hw_break))
 		arch_kgdb_ops.correct_hw_break();
@@ -1649,7 +1649,7 @@ static void dbg_restore_debug_regs(void)
 #define dbg_restore_debug_regs()
 #endif /* ! CONFIG_KGDB */
 
-static void wait_for_master_cpu(int cpu)
+void wait_for_master_cpu(int cpu)
 {
 #ifdef CONFIG_SMP
 	/*
@@ -1663,7 +1663,7 @@ static void wait_for_master_cpu(int cpu)
 }
 
 #ifdef CONFIG_X86_64
-static void setup_getcpu(int cpu)
+void setup_getcpu(int cpu)
 {
 	unsigned long cpudata = vdso_encode_cpunode(cpu, early_cpu_to_node(cpu));
 	struct desc_struct d = { };
@@ -1864,7 +1864,7 @@ void cpu_init(void)
 }
 #endif
 
-static void bsp_resume(void)
+void bsp_resume(void)
 {
 	if (this_cpu->c_bsp_resume)
 		this_cpu->c_bsp_resume(&boot_cpu_data);
@@ -1874,7 +1874,7 @@ static struct syscore_ops cpu_syscore_ops = {
 	.resume		= bsp_resume,
 };
 
-static int __init init_cpu_syscore(void)
+int __init init_cpu_syscore(void)
 {
 	register_syscore_ops(&cpu_syscore_ops);
 	return 0;
diff --git a/arch/x86/kernel/head64.c b/arch/x86/kernel/head64.c
index 16b1cbd3a61e..01892dd65776 100644
--- a/arch/x86/kernel/head64.c
+++ b/arch/x86/kernel/head64.c
@@ -63,23 +63,23 @@ EXPORT_SYMBOL(vmemmap_base);
 
 #define __head	__section(.head.text)
 
-static void __head *fixup_pointer(void *ptr, unsigned long physaddr)
+void __head *fixup_pointer(void *ptr, unsigned long physaddr)
 {
 	return ptr - (void *)_text + (void *)physaddr;
 }
 
-static unsigned long __head *fixup_long(void *ptr, unsigned long physaddr)
+unsigned long __head *fixup_long(void *ptr, unsigned long physaddr)
 {
 	return fixup_pointer(ptr, physaddr);
 }
 
 #ifdef CONFIG_X86_5LEVEL
-static unsigned int __head *fixup_int(void *ptr, unsigned long physaddr)
+unsigned int __head *fixup_int(void *ptr, unsigned long physaddr)
 {
 	return fixup_pointer(ptr, physaddr);
 }
 
-static bool __head check_la57_support(unsigned long physaddr)
+bool __head check_la57_support(unsigned long physaddr)
 {
 	/*
 	 * 5-level paging is detected and enabled at kernel decomression
@@ -98,7 +98,7 @@ static bool __head check_la57_support(unsigned long physaddr)
 	return true;
 }
 #else
-static bool __head check_la57_support(unsigned long physaddr)
+bool __head check_la57_support(unsigned long physaddr)
 {
 	return false;
 }
@@ -269,7 +269,7 @@ unsigned long __startup_secondary_64(void)
 }
 
 /* Wipe all early page tables except for the kernel symbol map */
-static void __init reset_early_page_tables(void)
+void __init reset_early_page_tables(void)
 {
 	memset(early_top_pgt, 0, sizeof(pgd_t)*(PTRS_PER_PGD-1));
 	next_early_pgt = 0;
@@ -359,13 +359,13 @@ int __init early_make_pgtable(unsigned long address)
 
 /* Don't add a printk in there. printk relies on the PDA which is not initialized 
    yet. */
-static void __init clear_bss(void)
+void __init clear_bss(void)
 {
 	memset(__bss_start, 0,
 	       (unsigned long) __bss_stop - (unsigned long) __bss_start);
 }
 
-static unsigned long get_cmd_line_ptr(void)
+unsigned long get_cmd_line_ptr(void)
 {
 	unsigned long cmd_line_ptr = boot_params.hdr.cmd_line_ptr;
 
@@ -374,7 +374,7 @@ static unsigned long get_cmd_line_ptr(void)
 	return cmd_line_ptr;
 }
 
-static void __init copy_bootdata(char *real_mode_data)
+void __init copy_bootdata(char *real_mode_data)
 {
 	char * command_line;
 	unsigned long cmd_line_ptr;
diff --git a/lib/decompress_inflate.c b/lib/decompress_inflate.c
index 63b4b7eee138..921526e1ddb5 100644
--- a/lib/decompress_inflate.c
+++ b/lib/decompress_inflate.c
@@ -194,7 +194,7 @@ STATIC int INIT gunzip(unsigned char *buf, long len,
 	return __gunzip(buf, len, fill, flush, out_buf, 0, pos, error);
 }
 #else
-STATIC int INIT __decompress(unsigned char *buf, long len,
+int __decompress(unsigned char *buf, long len,
 			   long (*fill)(void*, unsigned long),
 			   long (*flush)(void*, unsigned long),
 			   unsigned char *out_buf, long out_len,
